Imagine five philosophers sitting around a circular dining table. In front of each philosopher is a plate of spaghetti, and between each pair of philosophers is a single fork. To eat, a philosopher needs to use the two forks adjacent to their plate. The challenge is to design a protocol that ensures:


No two philosophers can use the same fork at the same time.
Philosophers don't starve (i.e., they eventually get to eat).
The system avoids deadlock, where all philosophers are waiting indefinitely to pick up a fork.

#include <iostream>
#include <thread>
#include <mutex>
#include <chrono>
#include <vector>

class DiningPhilosophers {
public:
    DiningPhilosophers(int numPhilosophers) : forks(numPhilosophers) {}

    void dine(int philosopher) {
        while (true) {
            think(philosopher);
            eat(philosopher);
        }
    }

private:
    std::vector<std::mutex> forks;

    void think(int philosopher) {
        std::cout << "Philosopher " << philosopher << " is thinking." << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }

    void eat(int philosopher) {
        int leftFork = philosopher;
        int rightFork = (philosopher + 1) % forks.size();

        // Pick up forks (use std::lock to avoid deadlock)
        std::lock(forks[leftFork], forks[rightFork]);

        std::lock_guard<std::mutex> leftLock(forks[leftFork], std::adopt_lock);
        std::lock_guard<std::mutex> rightLock(forks[rightFork], std::adopt_lock);

        std::cout << "Philosopher " << philosopher << " is eating." << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(150));

        // Forks are automatically released when lock_guard goes out of scope
    }
};

int main() {
    const int numPhilosophers = 5;
    DiningPhilosophers dp(numPhilosophers);
    std::vector<std::thread> philosophers;

    for (int i = 0; i < numPhilosophers; ++i) {
        philosophers.push_back(std::thread(&DiningPhilosophers::dine, &dp, i));
    }

    for (auto& philosopher : philosophers) {
        philosopher.join();
    }

    return 0;
}
